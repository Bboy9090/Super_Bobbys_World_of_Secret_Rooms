//! Real-time USB Device Monitoring - GOD MODE
//!
//! This module provides comprehensive hotplug monitoring with:
//! - Platform-specific implementations (Linux udev, Windows WM_DEVICECHANGE, macOS IOKit)
//! - Event debouncing for rapid connect/disconnect cycles
//! - Reconnection correlation (same device, different address)
//! - Device identity tracking across sessions

use crate::model::UsbDeviceRecord;
use std::collections::HashMap;
use std::sync::mpsc::Receiver;
use std::time::{Duration, Instant};

/// Device lifecycle events for hotplug monitoring.
/// 
/// These events represent state changes in the device detection system:
/// - `Added`: New device has completed detection pipeline and is confirmed
/// - `Removed`: Previously confirmed device has disconnected from bus
/// - `Changed`: Device state modified (driver binding, health status, etc.)
/// - `Reconnected`: Same device reconnected (matched by identity)
/// 
/// Events are generated by platform-specific watchers and sent via channels
/// to application code for reactive handling.
#[derive(Debug, Clone)]
pub enum DeviceEvent {
    /// Device connected and confirmed (ready for use)
    Added(UsbDeviceRecord),
    /// Device disconnected (no longer accessible)
    Removed(UsbDeviceRecord),
    /// Device state changed (driver, health, etc.)
    Changed(UsbDeviceRecord),
    /// Device reconnected (same identity, possibly different address)
    Reconnected {
        /// The reconnected device with new location
        device: UsbDeviceRecord,
        /// Previous location information
        previous_location: Option<crate::model::UsbLocation>,
    },
}

impl DeviceEvent {
    /// Get the device record from this event
    pub fn device(&self) -> &UsbDeviceRecord {
        match self {
            DeviceEvent::Added(d) => d,
            DeviceEvent::Removed(d) => d,
            DeviceEvent::Changed(d) => d,
            DeviceEvent::Reconnected { device, .. } => device,
        }
    }
    
    /// Check if this is an addition event
    pub fn is_added(&self) -> bool {
        matches!(self, DeviceEvent::Added(_) | DeviceEvent::Reconnected { .. })
    }
    
    /// Check if this is a removal event
    pub fn is_removed(&self) -> bool {
        matches!(self, DeviceEvent::Removed(_))
    }
}

/// Trait for real-time USB device hotplug monitoring.
/// 
/// DeviceWatcher implementations use platform-specific notification mechanisms
/// to detect USB device connection and disconnection events:
/// - Linux: udev monitoring
/// - Windows: RegisterDeviceNotification API
/// - macOS: IOKit notifications
/// 
/// Watchers run on a separate thread and send DeviceEvent messages via a channel.
/// Applications receive events and handle them reactively.
/// 
/// # Thread Safety
/// Watchers are thread-safe and designed to run concurrently with device enumeration.
/// The start() method spawns a background thread, and stop() terminates it gracefully.
pub trait DeviceWatcher: Send + Sync {
    /// Start monitoring for device events. Returns a receiver for event messages.
    /// 
    /// The watcher will run on a background thread until stop() is called.
    fn start(&mut self) -> Result<Receiver<DeviceEvent>, Box<dyn std::error::Error>>;
    
    /// Stop monitoring and shut down the background thread.
    fn stop(&mut self) -> Result<(), Box<dyn std::error::Error>>;
}

/// Enhanced device watcher with debouncing and reconnection correlation
pub struct EnhancedDeviceWatcher<W: DeviceWatcher> {
    inner: W,
    /// Debounce duration for rapid events
    debounce_duration: Duration,
    /// Maximum time to consider a reconnection (not a new device)
    reconnect_window: Duration,
    /// Track recently removed devices for reconnection correlation
    recent_removals: HashMap<DeviceIdentity, (UsbDeviceRecord, Instant)>,
    /// Track pending events for debouncing
    pending_events: HashMap<DeviceIdentity, (DeviceEvent, Instant)>,
}

impl<W: DeviceWatcher> EnhancedDeviceWatcher<W> {
    /// Create a new enhanced watcher with default settings
    pub fn new(inner: W) -> Self {
        Self {
            inner,
            debounce_duration: Duration::from_millis(100),
            reconnect_window: Duration::from_secs(5),
            recent_removals: HashMap::new(),
            pending_events: HashMap::new(),
        }
    }
    
    /// Set the debounce duration
    pub fn with_debounce(mut self, duration: Duration) -> Self {
        self.debounce_duration = duration;
        self
    }
    
    /// Set the reconnection window
    pub fn with_reconnect_window(mut self, duration: Duration) -> Self {
        self.reconnect_window = duration;
        self
    }
    
    /// Process an event with debouncing and reconnection correlation
    pub fn process_event(&mut self, event: DeviceEvent) -> Option<DeviceEvent> {
        let identity = DeviceIdentity::from_record(event.device());
        let now = Instant::now();
        
        // Clean up old entries
        self.recent_removals.retain(|_, (_, time)| now.duration_since(*time) < self.reconnect_window);
        self.pending_events.retain(|_, (_, time)| now.duration_since(*time) < self.debounce_duration);
        
        match &event {
            DeviceEvent::Added(device) => {
                // Check if this is a reconnection
                if let Some((previous, _)) = self.recent_removals.remove(&identity) {
                    return Some(DeviceEvent::Reconnected {
                        device: device.clone(),
                        previous_location: Some(previous.location),
                    });
                }
                
                // Check for pending removal (debounce)
                if self.pending_events.contains_key(&identity) {
                    // Cancel the pending removal - device reconnected quickly
                    self.pending_events.remove(&identity);
                    return None; // Don't emit event
                }
                
                Some(event)
            }
            DeviceEvent::Removed(device) => {
                // Check for pending addition (debounce)
                if self.pending_events.contains_key(&identity) {
                    self.pending_events.remove(&identity);
                    return None;
                }
                
                // Store for reconnection correlation
                self.recent_removals.insert(identity.clone(), (device.clone(), now));
                
                // Add to pending for debouncing
                self.pending_events.insert(identity, (event.clone(), now));
                
                // Return the event (caller should handle debouncing)
                Some(event)
            }
            DeviceEvent::Changed(_) | DeviceEvent::Reconnected { .. } => {
                Some(event)
            }
        }
    }
    
    /// Flush pending events that have passed the debounce window
    pub fn flush_pending(&mut self) -> Vec<DeviceEvent> {
        let now = Instant::now();
        let mut flushed = Vec::new();
        
        self.pending_events.retain(|_, (event, time)| {
            if now.duration_since(*time) >= self.debounce_duration {
                flushed.push(event.clone());
                false
            } else {
                true
            }
        });
        
        flushed
    }
}

impl<W: DeviceWatcher> DeviceWatcher for EnhancedDeviceWatcher<W> {
    fn start(&mut self) -> Result<Receiver<DeviceEvent>, Box<dyn std::error::Error>> {
        self.inner.start()
    }
    
    fn stop(&mut self) -> Result<(), Box<dyn std::error::Error>> {
        self.inner.stop()
    }
}

/// Device identity for tracking across reconnections
#[derive(Debug, Clone, Hash, PartialEq, Eq)]
pub struct DeviceIdentity {
    /// VID:PID combination
    vid_pid: (u16, u16),
    /// Serial number (if available)
    serial: Option<String>,
    /// Port path (if available and no serial)
    port_path: Option<String>,
}

impl DeviceIdentity {
    /// Create identity from a device record
    pub fn from_record(record: &UsbDeviceRecord) -> Self {
        Self {
            vid_pid: (record.id.vid, record.id.pid),
            serial: record.descriptor.serial_number.clone(),
            port_path: if record.descriptor.serial_number.is_some() {
                None // Don't use port path if we have serial
            } else {
                record.location.port_path.clone()
            },
        }
    }
    
    /// Create identity from VID/PID and serial
    pub fn from_vid_pid_serial(vid: u16, pid: u16, serial: Option<String>) -> Self {
        Self {
            vid_pid: (vid, pid),
            serial,
            port_path: None,
        }
    }
    
    /// Check if this identity matches a device record
    pub fn matches(&self, record: &UsbDeviceRecord) -> bool {
        // Must match VID:PID
        if self.vid_pid != (record.id.vid, record.id.pid) {
            return false;
        }
        
        // If we have serial, compare by serial
        if let Some(ref our_serial) = self.serial {
            if let Some(ref their_serial) = record.descriptor.serial_number {
                return our_serial == their_serial;
            }
            return false;
        }
        
        // If we have port path, compare by port path
        if let Some(ref our_path) = self.port_path {
            if let Some(ref their_path) = record.location.port_path {
                return our_path == their_path;
            }
        }
        
        // Fallback: VID:PID only match (less reliable)
        true
    }
}

/// Device session tracker for managing device lifecycles
pub struct DeviceSessionTracker {
    /// Active sessions by identity
    sessions: HashMap<DeviceIdentity, DeviceSession>,
    /// Session counter for unique IDs
    session_counter: u64,
}

impl DeviceSessionTracker {
    pub fn new() -> Self {
        Self {
            sessions: HashMap::new(),
            session_counter: 0,
        }
    }
    
    /// Register a new device session
    pub fn register(&mut self, device: &UsbDeviceRecord) -> DeviceSession {
        let identity = DeviceIdentity::from_record(device);
        self.session_counter += 1;
        
        let session = DeviceSession {
            id: self.session_counter,
            identity: identity.clone(),
            device: device.clone(),
            connected_at: Instant::now(),
            reconnect_count: 0,
        };
        
        self.sessions.insert(identity, session.clone());
        session
    }
    
    /// Update session for reconnection
    pub fn reconnect(&mut self, device: &UsbDeviceRecord) -> Option<DeviceSession> {
        let identity = DeviceIdentity::from_record(device);
        
        if let Some(session) = self.sessions.get_mut(&identity) {
            session.device = device.clone();
            session.reconnect_count += 1;
            return Some(session.clone());
        }
        
        None
    }
    
    /// Remove a device session
    pub fn remove(&mut self, device: &UsbDeviceRecord) -> Option<DeviceSession> {
        let identity = DeviceIdentity::from_record(device);
        self.sessions.remove(&identity)
    }
    
    /// Get session for a device
    pub fn get(&self, device: &UsbDeviceRecord) -> Option<&DeviceSession> {
        let identity = DeviceIdentity::from_record(device);
        self.sessions.get(&identity)
    }
    
    /// Get all active sessions
    pub fn active_sessions(&self) -> impl Iterator<Item = &DeviceSession> {
        self.sessions.values()
    }
}

impl Default for DeviceSessionTracker {
    fn default() -> Self {
        Self::new()
    }
}

/// Represents an active device session
#[derive(Debug, Clone)]
pub struct DeviceSession {
    /// Unique session ID
    pub id: u64,
    /// Device identity
    pub identity: DeviceIdentity,
    /// Current device record
    pub device: UsbDeviceRecord,
    /// When the device was first connected
    pub connected_at: Instant,
    /// Number of times the device has reconnected
    pub reconnect_count: u32,
}

impl DeviceSession {
    /// Get session duration
    pub fn duration(&self) -> Duration {
        self.connected_at.elapsed()
    }
}

#[cfg(target_os = "linux")]
pub mod linux;
#[cfg(target_os = "macos")]
pub mod macos;
#[cfg(target_os = "windows")]
pub mod windows;

// Re-export platform-specific watcher
#[cfg(target_os = "linux")]
pub use linux::LinuxDeviceWatcher as PlatformWatcher;
#[cfg(target_os = "macos")]
pub use macos::MacOSDeviceWatcher as PlatformWatcher;
#[cfg(target_os = "windows")]
pub use windows::WindowsDeviceWatcher as PlatformWatcher;

#[cfg(test)]
mod tests {
    use super::*;
    use crate::model::*;

    fn create_test_device(vid: u16, pid: u16, serial: Option<&str>) -> UsbDeviceRecord {
        UsbDeviceRecord {
            id: UsbId::new(vid, pid),
            location: UsbLocation {
                bus: Some(1),
                address: Some(1),
                port_path: Some("1-1".to_string()),
            },
            descriptor: UsbDescriptorSummary {
                manufacturer: None,
                product: None,
                serial_number: serial.map(|s| s.to_string()),
                device_class: None,
                device_subclass: None,
                device_protocol: None,
                usb_version: None,
            },
            driver: DriverStatus::Unknown,
            health: LinkHealth::Good,
            tags: vec![],
            raw_data: None,
        }
    }

    #[test]
    fn test_device_identity_with_serial() {
        let device = create_test_device(0x1234, 0x5678, Some("ABC123"));
        let identity = DeviceIdentity::from_record(&device);
        
        assert_eq!(identity.vid_pid, (0x1234, 0x5678));
        assert_eq!(identity.serial, Some("ABC123".to_string()));
        assert!(identity.port_path.is_none()); // Not used when serial is present
    }

    #[test]
    fn test_device_identity_without_serial() {
        let device = create_test_device(0x1234, 0x5678, None);
        let identity = DeviceIdentity::from_record(&device);
        
        assert_eq!(identity.vid_pid, (0x1234, 0x5678));
        assert!(identity.serial.is_none());
        assert_eq!(identity.port_path, Some("1-1".to_string()));
    }

    #[test]
    fn test_identity_matching() {
        let device1 = create_test_device(0x1234, 0x5678, Some("ABC123"));
        let device2 = create_test_device(0x1234, 0x5678, Some("ABC123"));
        let device3 = create_test_device(0x1234, 0x5678, Some("XYZ789"));
        
        let identity = DeviceIdentity::from_record(&device1);
        
        assert!(identity.matches(&device2));
        assert!(!identity.matches(&device3));
    }

    #[test]
    fn test_session_tracker() {
        let mut tracker = DeviceSessionTracker::new();
        let device = create_test_device(0x1234, 0x5678, Some("ABC123"));
        
        let session = tracker.register(&device);
        assert_eq!(session.id, 1);
        assert_eq!(session.reconnect_count, 0);
        
        assert!(tracker.get(&device).is_some());
        
        let removed = tracker.remove(&device);
        assert!(removed.is_some());
        assert!(tracker.get(&device).is_none());
    }

    #[test]
    fn test_event_types() {
        let device = create_test_device(0x1234, 0x5678, Some("ABC123"));
        
        let added = DeviceEvent::Added(device.clone());
        assert!(added.is_added());
        assert!(!added.is_removed());
        
        let removed = DeviceEvent::Removed(device.clone());
        assert!(!removed.is_added());
        assert!(removed.is_removed());
    }
}
